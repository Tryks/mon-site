<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra Picross - Créateur & Joueur</title>
    <style>
        :root {
            --primary-color: #6a5acd;
            --secondary-color: #9370db;
            --accent-color: #483d8b;
            --light-color: #f8f8ff;
            --dark-color: #2f2f4f;
            --correct-color: #7fffd4;
            --error-color: #ff7f7f;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light-color);
            color: var(--dark-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .subtitle {
            color: var(--accent-color);
            font-style: italic;
        }
        
        .app-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
            max-width: 1400px;
        }
        
        .game-section, .editor-section {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
            flex: 1;
            min-width: 300px;
            max-width: 600px;
        }
        
        .section-title {
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
            margin-top: 0;
        }
        
        .grid-container {
            display: inline-block;
            margin: 20px auto;
            border: 3px solid var(--dark-color);
            position: relative;
        }
        
        .picross-grid {
            border-collapse: collapse;
        }
        
        .picross-grid td {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            text-align: center;
            vertical-align: middle;
            cursor: pointer;
            position: relative;
            background-color: white;
            transition: all 0.2s;
        }
        
        .picross-grid td:hover {
            background-color: #f0f0f0;
        }
        
        .picross-grid td.filled {
            background-color: var(--dark-color);
        }
        
        .picross-grid td.marked {
            background-color: var(--light-color);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cline x1='0' y1='0' x2='20' y2='20' stroke='%23ff0000' stroke-width='2'/%3E%3Cline x1='20' y1='0' x2='0' y2='20' stroke='%23ff0000' stroke-width='2'/%3E%3C/svg%3E");
            background-size: contain;
        }
        
        .picross-grid td.correct {
            background-color: var(--correct-color);
        }
        
        .picross-grid td.error {
            background-color: var(--error-color);
        }
        
        .row-hints, .col-hints {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .row-hints {
            flex-direction: column;
            position: absolute;
            left: -60px;
            top: 0;
        }
        
        .col-hints {
            position: absolute;
            top: -40px;
            left: 0;
        }
        
        .hint-cell {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: var(--accent-color);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        button:hover {
            background-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background-color: var(--secondary-color);
        }
        
        button.danger {
            background-color: var(--error-color);
        }
        
        select, input {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        
        .size-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .tool-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .tool-btn {
            padding: 8px 12px;
        }
        
        .active-tool {
            background-color: var(--accent-color);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }
        
        .palette {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .color-option.selected {
            border-color: var(--dark-color);
            transform: scale(1.1);
        }
        
        .save-load {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .close-modal {
            float: right;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .theme-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        
        .theme {
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .theme.selected {
            border-color: var(--dark-color);
        }
        
        .theme-classic {
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0);
        }
        
        .theme-dark {
            background: linear-gradient(135deg, #2d2d2d, #1a1a1a);
            color: white;
        }
        
        .theme-ocean {
            background: linear-gradient(135deg, #e0f7fa, #b2ebf2);
        }
        
        .theme-forest {
            background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
        }
        
        .difficulty-selector {
            margin: 15px 0;
        }
        
        .stats {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 10px;
        }
        
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-section, .editor-section {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Ultra Picross</h1>
        <p class="subtitle">Créez et résolvez des grilles logiques magnifiques</p>
    </header>
    
    <div class="app-container">
        <section class="game-section">
            <h2 class="section-title">Jouer</h2>
            <div class="size-selector">
                <label for="game-size">Taille :</label>
                <select id="game-size">
                    <option value="5">5x5</option>
                    <option value="10" selected>10x10</option>
                    <option value="15">15x15</option>
                    <option value="20">20x20</option>
                </select>
                
                <label for="game-difficulty">Difficulté :</label>
                <select id="game-difficulty">
                    <option value="easy">Facile</option>
                    <option value="medium" selected>Moyen</option>
                    <option value="hard">Difficile</option>
                    <option value="expert">Expert</option>
                </select>
            </div>
            
            <div class="controls">
                <button id="new-game">Nouvelle Grille</button>
                <button id="check-game">Vérifier</button>
                <button id="solve-game">Solution</button>
                <button id="hint-game">Indice</button>
                <button id="theme-btn">Thèmes</button>
            </div>
            
            <div class="grid-container" id="game-container">
                <!-- La grille de jeu sera générée ici -->
            </div>
            
            <div class="stats">
                <p>Temps : <span id="game-time">00:00</span></p>
                <p>Cases restantes : <span id="remaining-cells">0</span></p>
                <p>Indices utilisés : <span id="hints-used">0</span></p>
            </div>
        </section>
        
        <section class="editor-section">
            <h2 class="section-title">Créateur de Niveaux</h2>
            <div class="size-selector">
                <label for="editor-size">Taille :</label>
                <select id="editor-size">
                    <option value="5">5x5</option>
                    <option value="10" selected>10x10</option>
                    <option value="15">15x15</option>
                    <option value="20">20x20</option>
                </select>
                
                <button id="resize-editor">Redimensionner</button>
            </div>
            
            <div class="tool-selector">
                <p>Outil :</p>
                <button class="tool-btn active-tool" data-tool="fill">Remplir</button>
                <button class="tool-btn" data-tool="mark">Marquer</button>
                <button class="tool-btn" data-tool="erase">Effacer</button>
            </div>
            
            <div class="palette">
                <div class="color-option selected" style="background-color: #000000;" data-color="0"></div>
                <div class="color-option" style="background-color: #ff0000;" data-color="1"></div>
                <div class="color-option" style="background-color: #00ff00;" data-color="2"></div>
                <div class="color-option" style="background-color: #0000ff;" data-color="3"></div>
                <div class="color-option" style="background-color: #ffff00;" data-color="4"></div>
            </div>
            
            <div class="grid-container" id="editor-container">
                <!-- La grille d'édition sera générée ici -->
            </div>
            
            <div class="controls">
                <button id="test-puzzle">Tester cette grille</button>
                <button id="clear-editor">Effacer tout</button>
                <button id="random-puzzle">Générer aléatoire</button>
            </div>
            
            <div class="save-load">
                <button id="save-puzzle">Enregistrer</button>
                <button id="load-puzzle">Charger</button>
                <button id="export-puzzle">Exporter</button>
                <button id="import-puzzle">Importer</button>
            </div>
        </section>
    </div>
    
    <!-- Modals -->
    <div class="modal" id="theme-modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>Choisissez un thème</h2>
            <div class="theme-selector">
                <div class="theme theme-classic selected" data-theme="classic">
                    Classique
                </div>
                <div class="theme theme-dark" data-theme="dark">
                    Sombre
                </div>
                <div class="theme theme-ocean" data-theme="ocean">
                    Océan
                </div>
                <div class="theme theme-forest" data-theme="forest">
                    Forêt
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="save-modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>Enregistrer la grille</h2>
            <label for="puzzle-name">Nom de la grille :</label>
            <input type="text" id="puzzle-name" placeholder="Mon super picross">
            <div class="controls" style="margin-top: 20px;">
                <button id="confirm-save">Enregistrer</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="load-modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>Charger une grille</h2>
            <div id="saved-puzzles">
                <!-- Les grilles sauvegardées apparaîtront ici -->
                <p>Aucune grille sauvegardée.</p>
            </div>
        </div>
    </div>
    
    <div class="modal" id="export-modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>Exporter la grille</h2>
            <p>Copiez ce code pour partager votre grille :</p>
            <textarea id="export-code" rows="10" style="width: 100%;"></textarea>
            <div class="controls" style="margin-top: 10px;">
                <button id="copy-export">Copier</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="import-modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>Importer une grille</h2>
            <p>Collez le code de la grille :</p>
            <textarea id="import-code" rows="10" style="width: 100%;"></textarea>
            <div class="controls" style="margin-top: 10px;">
                <button id="confirm-import">Importer</button>
            </div>
        </div>
    </div>
    
    <script>
        // Variables globales
        let currentGameGrid = [];
        let currentEditorGrid = [];
        let gameSize = 10;
        let editorSize = 10;
        let gameTimer = null;
        let seconds = 0;
        let hintsUsed = 0;
        let currentTool = 'fill';
        let currentColor = '0';
        let savedPuzzles = JSON.parse(localStorage.getItem('savedPuzzles')) || [];
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            initGame();
            initEditor();
            setupEventListeners();
            
            // Démarrer avec une grille aléatoire
            generateRandomGame();
        });
        
        // Initialisation du jeu
        function initGame() {
            gameSize = parseInt(document.getElementById('game-size').value);
            createGameGrid(gameSize);
            updateGameStats();
        }
        
        // Initialisation de l'éditeur
        function initEditor() {
            editorSize = parseInt(document.getElementById('editor-size').value);
            createEditorGrid(editorSize);
        }
        
        // Création de la grille de jeu
        function createGameGrid(size) {
            const container = document.getElementById('game-container');
            container.innerHTML = '';
            
            // Créer les indices de colonnes
            const colHints = document.createElement('div');
            colHints.className = 'col-hints';
            
            // Créer les indices de lignes
            const rowHints = document.createElement('div');
            rowHints.className = 'row-hints';
            
            // Créer le tableau
            const table = document.createElement('table');
            table.className = 'picross-grid';
            
            // Initialiser la grille logique
            currentGameGrid = Array(size).fill().map(() => Array(size).fill(0));
            
            // Créer les lignes et cellules
            for (let i = 0; i < size; i++) {
                const row = document.createElement('tr');
                
                // Ajouter l'indice de ligne
                const rowHint = document.createElement('div');
                rowHint.className = 'hint-cell';
                rowHint.textContent = '';
                rowHints.appendChild(rowHint);
                
                for (let j = 0; j < size; j++) {
                    const cell = document.createElement('td');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    cell.addEventListener('click', function() {
                        handleGameCellClick(i, j);
                    });
                    
                    cell.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                        handleGameCellRightClick(i, j);
                    });
                    
                    row.appendChild(cell);
                }
                table.appendChild(row);
                
                // Ajouter l'indice de colonne (première ligne seulement)
                if (i === 0) {
                    for (let j = 0; j < size; j++) {
                        const colHint = document.createElement('div');
                        colHint.className = 'hint-cell';
                        colHint.textContent = '';
                        colHints.appendChild(colHint);
                    }
                }
            }
            
            container.appendChild(colHints);
            container.appendChild(rowHints);
            container.appendChild(table);
        }
        
        // Création de la grille d'édition
        function createEditorGrid(size) {
            const container = document.getElementById('editor-container');
            container.innerHTML = '';
            
            // Initialiser la grille d'édition
            currentEditorGrid = Array(size).fill().map(() => Array(size).fill(0));
            
            // Créer le tableau
            const table = document.createElement('table');
            table.className = 'picross-grid';
            
            // Créer les lignes et cellules
            for (let i = 0; i < size; i++) {
                const row = document.createElement('tr');
                
                for (let j = 0; j < size; j++) {
                    const cell = document.createElement('td');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    cell.addEventListener('click', function() {
                        handleEditorCellClick(i, j);
                    });
                    
                    cell.addEventListener('mouseenter', function() {
                        if (isMouseDown) {
                            handleEditorCellClick(i, j);
                        }
                    });
                    
                    row.appendChild(cell);
                }
                table.appendChild(row);
            }
            
            container.appendChild(table);
        }
        
        // Gestion des événements
        function setupEventListeners() {
            // Jeu
            document.getElementById('new-game').addEventListener('click', generateRandomGame);
            document.getElementById('check-game').addEventListener('click', checkGameSolution);
            document.getElementById('solve-game').addEventListener('click', showGameSolution);
            document.getElementById('hint-game').addEventListener('click', giveHint);
            document.getElementById('game-size').addEventListener('change', initGame);
            document.getElementById('game-difficulty').addEventListener('change', generateRandomGame);
            document.getElementById('theme-btn').addEventListener('click', () => {
                document.getElementById('theme-modal').style.display = 'flex';
            });
            
            // Éditeur
            document.getElementById('resize-editor').addEventListener('click', initEditor);
            document.getElementById('editor-size').addEventListener('change', function() {
                editorSize = parseInt(this.value);
            });
            document.getElementById('test-puzzle').addEventListener('click', testPuzzle);
            document.getElementById('clear-editor').addEventListener('click', clearEditor);
            document.getElementById('random-puzzle').addEventListener('click', generateRandomEditor);
            document.getElementById('save-puzzle').addEventListener('click', () => {
                document.getElementById('save-modal').style.display = 'flex';
            });
            document.getElementById('load-puzzle').addEventListener('click', () => {
                showSavedPuzzles();
                document.getElementById('load-modal').style.display = 'flex';
            });
            document.getElementById('export-puzzle').addEventListener('click', showExportModal);
            document.getElementById('import-puzzle').addEventListener('click', () => {
                document.getElementById('import-modal').style.display = 'flex';
            });
            
            // Outils éditeur
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active-tool'));
                    this.classList.add('active-tool');
                    currentTool = this.dataset.tool;
                });
            });
            
            // Palette de couleurs
            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    currentColor = this.dataset.color;
                });
            });
            
            // Modals
            document.querySelectorAll('.close-modal').forEach(closeBtn => {
                closeBtn.addEventListener('click', function() {
                    this.closest('.modal').style.display = 'none';
                });
            });
            
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        this.style.display = 'none';
                    }
                });
            });
            
            // Thèmes
            document.querySelectorAll('.theme').forEach(theme => {
                theme.addEventListener('click', function() {
                    document.querySelectorAll('.theme').forEach(t => t.classList.remove('selected'));
                    this.classList.add('selected');
                    applyTheme(this.dataset.theme);
                });
            });
            
            // Sauvegarde
            document.getElementById('confirm-save').addEventListener('click', savePuzzle);
            
            // Import/Export
            document.getElementById('copy-export').addEventListener('click', copyExportCode);
            document.getElementById('confirm-import').addEventListener('click', importPuzzle);
        }
        
        // Gestion du clic sur une cellule de jeu
        function handleGameCellClick(row, col) {
            const cell = document.querySelector(`#game-container td[data-row="${row}"][data-col="${col}"]`);
            
            if (cell.classList.contains('filled')) {
                cell.classList.remove('filled');
                currentGameGrid[row][col] = 0;
            } else {
                cell.classList.remove('marked');
                cell.classList.add('filled');
                currentGameGrid[row][col] = 1;
            }
            
            updateGameStats();
            checkGameCompletion();
        }
        
        // Gestion du clic droit sur une cellule de jeu
        function handleGameCellRightClick(row, col) {
            const cell = document.querySelector(`#game-container td[data-row="${row}"][data-col="${col}"]`);
            
            if (cell.classList.contains('marked')) {
                cell.classList.remove('marked');
            } else {
                cell.classList.remove('filled');
                cell.classList.add('marked');
            }
            
            updateGameStats();
        }
        
        // Gestion du clic sur une cellule d'édition
        let isMouseDown = false;
        document.addEventListener('mousedown', () => { isMouseDown = true; });
        document.addEventListener('mouseup', () => { isMouseDown = false; });
        
        function handleEditorCellClick(row, col) {
            const cell = document.querySelector(`#editor-container td[data-row="${row}"][data-col="${col}"]`);
            
            if (currentTool === 'fill') {
                cell.classList.remove('marked');
                cell.classList.add('filled');
                cell.style.backgroundColor = getColorFromPalette(currentColor);
                currentEditorGrid[row][col] = currentColor;
            } else if (currentTool === 'mark') {
                cell.classList.remove('filled');
                cell.classList.add('marked');
                currentEditorGrid[row][col] = 'X';
            } else if (currentTool === 'erase') {
                cell.classList.remove('filled', 'marked');
                currentEditorGrid[row][col] = 0;
            }
        }
        
        // Générer une grille aléatoire pour le jeu
        function generateRandomGame() {
            stopTimer();
            seconds = 0;
            hintsUsed = 0;
            updateGameStats();
            
            const size = parseInt(document.getElementById('game-size').value);
            const difficulty = document.getElementById('game-difficulty').value;
            
            // Créer une solution aléatoire basée sur la difficulté
            const solution = Array(size).fill().map(() => Array(size).fill(0));
            let fillProbability;
            
            switch (difficulty) {
                case 'easy': fillProbability = 0.3; break;
                case 'medium': fillProbability = 0.4; break;
                case 'hard': fillProbability = 0.5; break;
                case 'expert': fillProbability = 0.6; break;
                default: fillProbability = 0.4;
            }
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    solution[i][j] = Math.random() < fillProbability ? 1 : 0;
                }
            }
            
            // Stocker la solution et initialiser la grille de jeu
            currentGameGrid = Array(size).fill().map(() => Array(size).fill(0));
            
            // Mettre à jour l'affichage
            const cells = document.querySelectorAll('#game-container td');
            cells.forEach(cell => {
                cell.classList.remove('filled', 'marked', 'correct', 'error');
            });
            
            // Calculer et afficher les indices
            updateHints(solution);
            
            // Démarrer le timer
            startTimer();
        }
        
        // Générer une grille aléatoire pour l'éditeur
        function generateRandomEditor() {
            const size = editorSize;
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    currentEditorGrid[i][j] = Math.random() < 0.4 ? '1' : '0';
                }
            }
            
            // Mettre à jour l'affichage
            const cells = document.querySelectorAll('#editor-container td');
            cells.forEach((cell, index) => {
                const row = Math.floor(index / size);
                const col = index % size;
                
                cell.classList.remove('filled', 'marked');
                
                if (currentEditorGrid[row][col] !== '0') {
                    cell.classList.add('filled');
                    cell.style.backgroundColor = getColorFromPalette(currentEditorGrid[row][col]);
                }
            });
        }
        
        // Mettre à jour les indices (nombres sur les côtés)
        function updateHints(solution) {
            const size = solution.length;
            
            // Indices des lignes (à gauche)
            const rowHints = document.querySelectorAll('#game-container .row-hints .hint-cell');
            for (let i = 0; i < size; i++) {
                const hints = calculateHints(solution[i]);
                rowHints[i].textContent = hints.join('\n');
                rowHints[i].title = hints.join(', ');
            }
            
            // Indices des colonnes (en haut)
            const colHints = document.querySelectorAll('#game-container .col-hints .hint-cell');
            for (let j = 0; j < size; j++) {
                const column = solution.map(row => row[j]);
                const hints = calculateHints(column);
                colHints[j].textContent = hints.join(' ');
                colHints[j].title = hints.join(', ');
            }
        }
        
        // Calculer les indices pour une ligne/colonne
        function calculateHints(line) {
            const hints = [];
            let count = 0;
            
            for (const cell of line) {
                if (cell === 1 || cell === '1') {
                    count++;
                } else if (count > 0) {
                    hints.push(count);
                    count = 0;
                }
            }
            
            if (count > 0 || hints.length === 0) {
                hints.push(count);
            }
            
            return hints.filter(h => h > 0);
        }
        
        // Vérifier la solution
        function checkGameSolution() {
            // Cette fonction vérifie si la grille actuelle correspond à la solution
            // Dans une vraie implémentation, vous auriez besoin de stocker la solution
            // Pour cette démo, nous allons simplement marquer les cases correctes et incorrectes
            
            const size = gameSize;
            let allCorrect = true;
            
            // Dans une vraie implémentation, vous compareriez avec la solution réelle
            // Ici, nous supposons que toutes les cases remplies sont correctes
            // et marquons les cases marquées comme potentielles erreurs
            
            const cells = document.querySelectorAll('#game-container td');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                if (cell.classList.contains('filled')) {
                    cell.classList.add('correct');
                    cell.classList.remove('error');
                } else if (cell.classList.contains('marked')) {
                    // Vérifier si la marque est correcte (la case devrait être vide)
                    // Dans cette démo, nous supposons que c'est correct
                    cell.classList.add('correct');
                    cell.classList.remove('error');
                } else {
                    // Case vide - pourrait être une erreur si elle devrait être remplie
                    cell.classList.remove('correct', 'error');
                }
            });
            
            return allCorrect;
        }
        
        // Afficher la solution complète
        function showGameSolution() {
            const cells = document.querySelectorAll('#game-container td');
            cells.forEach(cell => {
                cell.classList.remove('filled', 'marked', 'correct', 'error');
                
                // Dans une vraie implémentation, vous rempliriez selon la solution
                // Pour cette démo, nous remplissons aléatoirement certaines cases
                if (Math.random() > 0.7) {
                    cell.classList.add('filled');
                }
            });
            
            stopTimer();
        }
        
        // Donner un indice
        function giveHint() {
            const emptyCells = Array.from(document.querySelectorAll('#game-container td:not(.filled):not(.marked)'));
            
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                
                // Dans une vraie implémentation, vous vérifieriez la solution
                // Pour cette démo, nous marquons aléatoirement comme rempli ou marqué
                if (Math.random() > 0.5) {
                    randomCell.classList.add('filled');
                } else {
                    randomCell.classList.add('marked');
                }
                
                hintsUsed++;
                updateGameStats();
            }
        }
        
        // Vérifier si le jeu est terminé
        function checkGameCompletion() {
            // Dans une vraie implémentation, vous vérifieriez si la grille correspond à la solution
            // Pour cette démo, nous vérifions simplement si toutes les cases sont remplies ou marquées
            
            const cells = document.querySelectorAll('#game-container td');
            const allFilledOrMarked = Array.from(cells).every(cell => {
                return cell.classList.contains('filled') || cell.classList.contains('marked');
            });
            
            if (allFilledOrMarked) {
                const isCorrect = checkGameSolution();
                
                if (isCorrect) {
                    stopTimer();
                    setTimeout(() => {
                        alert('Félicitations ! Vous avez résolu le picross !\n\n' +
                              `Temps : ${formatTime(seconds)}\n` +
                              `Indices utilisés : ${hintsUsed}`);
                    }, 500);
                }
            }
        }
        
        // Tester le puzzle dans l'éditeur
        function testPuzzle() {
            // Convertir la grille d'édition en grille de jeu
            const size = editorSize;
            const solution = Array(size).fill().map(() => Array(size).fill(0));
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    solution[i][j] = currentEditorGrid[i][j] !== '0' ? 1 : 0;
                }
            }
            
            // Redimensionner le jeu si nécessaire
            if (size !== gameSize) {
                document.getElementById('game-size').value = size;
                initGame();
            }
            
            // Mettre à jour les indices
            updateHints(solution);
            
            // Réinitialiser la grille de jeu
            currentGameGrid = Array(size).fill().map(() => Array(size).fill(0));
            const cells = document.querySelectorAll('#game-container td');
            cells.forEach(cell => {
                cell.classList.remove('filled', 'marked', 'correct', 'error');
            });
            
            // Réinitialiser le timer
            stopTimer();
            seconds = 0;
            hintsUsed = 0;
            updateGameStats();
            startTimer();
            
            // Faire défiler jusqu'au jeu
            document.querySelector('.game-section').scrollIntoView({ behavior: 'smooth' });
        }
        
        // Effacer l'éditeur
        function clearEditor() {
            const size = editorSize;
            currentEditorGrid = Array(size).fill().map(() => Array(size).fill(0));
            
            const cells = document.querySelectorAll('#editor-container td');
            cells.forEach(cell => {
                cell.classList.remove('filled', 'marked');
                cell.style.backgroundColor = '';
            });
        }
        
        // Sauvegarder le puzzle
        function savePuzzle() {
            const name = document.getElementById('puzzle-name').value.trim();
            
            if (name) {
                const puzzle = {
                    name: name,
                    size: editorSize,
                    grid: currentEditorGrid,
                    date: new Date().toLocaleString()
                };
                
                savedPuzzles.push(puzzle);
                localStorage.setItem('savedPuzzles', JSON.stringify(savedPuzzles));
                
                document.getElementById('save-modal').style.display = 'none';
                document.getElementById('puzzle-name').value = '';
                
                alert(`Grille "${name}" sauvegardée avec succès !`);
            } else {
                alert('Veuillez entrer un nom pour la grille.');
            }
        }
        
        // Afficher les puzzles sauvegardés
        function showSavedPuzzles() {
            const container = document.getElementById('saved-puzzles');
            
            if (savedPuzzles.length === 0) {
                container.innerHTML = '<p>Aucune grille sauvegardée.</p>';
                return;
            }
            
            container.innerHTML = '<h3>Vos grilles sauvegardées :</h3><ul style="list-style-type: none; padding: 0;">';
            
            savedPuzzles.forEach((puzzle, index) => {
                const li = document.createElement('li');
                li.style.margin = '5px 0';
                li.style.padding = '10px';
                li.style.backgroundColor = '#f0f0f0';
                li.style.borderRadius = '5px';
                
                li.innerHTML = `
                    <strong>${puzzle.name}</strong> (${puzzle.size}x${puzzle.size})
                    <small>${puzzle.date}</small>
                    <button class="load-btn" data-index="${index}" style="float: right;">Charger</button>
                    <button class="delete-btn" data-index="${index}" style="float: right; margin-right: 5px;">Supprimer</button>
                `;
                
                container.appendChild(li);
            });
            
            // Ajouter les événements aux boutons
            document.querySelectorAll('.load-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    loadPuzzle(parseInt(this.dataset.index));
                    document.getElementById('load-modal').style.display = 'none';
                });
            });
            
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    deletePuzzle(parseInt(this.dataset.index));
                });
            });
        }
        
        // Charger un puzzle
        function loadPuzzle(index) {
            if (index >= 0 && index < savedPuzzles.length) {
                const puzzle = savedPuzzles[index];
                
                // Redimensionner l'éditeur si nécessaire
                if (puzzle.size !== editorSize) {
                    document.getElementById('editor-size').value = puzzle.size;
                    editorSize = puzzle.size;
                    initEditor();
                }
                
                // Charger la grille
                currentEditorGrid = puzzle.grid.map(row => [...row]);
                
                // Mettre à jour l'affichage
                const cells = document.querySelectorAll('#editor-container td');
                cells.forEach((cell, i) => {
                    const row = Math.floor(i / editorSize);
                    const col = i % editorSize;
                    
                    cell.classList.remove('filled', 'marked');
                    cell.style.backgroundColor = '';
                    
                    if (currentEditorGrid[row][col] === 'X') {
                        cell.classList.add('marked');
                    } else if (currentEditorGrid[row][col] !== '0') {
                        cell.classList.add('filled');
                        cell.style.backgroundColor = getColorFromPalette(currentEditorGrid[row][col]);
                    }
                });
            }
        }
        
        // Supprimer un puzzle
        function deletePuzzle(index) {
            if (confirm('Êtes-vous sûr de vouloir supprimer cette grille ?')) {
                savedPuzzles.splice(index, 1);
                localStorage.setItem('savedPuzzles', JSON.stringify(savedPuzzles));
                showSavedPuzzles();
            }
        }
        
        // Exporter un puzzle
        function showExportModal() {
            const puzzleData = {
                size: editorSize,
                grid: currentEditorGrid,
                name: `Picross ${editorSize}x${editorSize}`
            };
            
            document.getElementById('export-code').value = JSON.stringify(puzzleData, null, 2);
            document.getElementById('export-modal').style.display = 'flex';
        }
        
        // Copier le code d'export
        function copyExportCode() {
            const exportCode = document.getElementById('export-code');
            exportCode.select();
            document.execCommand('copy');
            alert('Code copié dans le presse-papiers !');
        }
        
        // Importer un puzzle
        function importPuzzle() {
            const importCode = document.getElementById('import-code').value.trim();
            
            try {
                const puzzleData = JSON.parse(importCode);
                
                if (!puzzleData.size || !puzzleData.grid) {
                    throw new Error('Format de grille invalide');
                }
                
                // Redimensionner l'éditeur si nécessaire
                if (puzzleData.size !== editorSize) {
                    document.getElementById('editor-size').value = puzzleData.size;
                    editorSize = puzzleData.size;
                    initEditor();
                }
                
                // Charger la grille
                currentEditorGrid = puzzleData.grid.map(row => [...row]);
                
                // Mettre à jour l'affichage
                const cells = document.querySelectorAll('#editor-container td');
                cells.forEach((cell, i) => {
                    const row = Math.floor(i / editorSize);
                    const col = i % editorSize;
                    
                    cell.classList.remove('filled', 'marked');
                    cell.style.backgroundColor = '';
                    
                    if (currentEditorGrid[row][col] === 'X') {
                        cell.classList.add('marked');
                    } else if (currentEditorGrid[row][col] !== '0') {
                        cell.classList.add('filled');
                        cell.style.backgroundColor = getColorFromPalette(currentEditorGrid[row][col]);
                    }
                });
                
                document.getElementById('import-modal').style.display = 'none';
                document.getElementById('import-code').value = '';
                
                alert('Grille importée avec succès !');
            } catch (e) {
                alert('Erreur lors de l\'importation : ' + e.message);
            }
        }
        
        // Gestion du timer
        function startTimer() {
            stopTimer();
            updateGameStats();
            gameTimer = setInterval(() => {
                seconds++;
                updateGameStats();
            }, 1000);
        }
        
        function stopTimer() {
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
        }
        
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Mettre à jour les statistiques du jeu
        function updateGameStats() {
            document.getElementById('game-time').textContent = formatTime(seconds);
            
            const size = gameSize;
            const totalCells = size * size;
            const filledCells = document.querySelectorAll('#game-container td.filled').length;
            const markedCells = document.querySelectorAll('#game-container td.marked').length;
            const remainingCells = totalCells - filledCells - markedCells;
            
            document.getElementById('remaining-cells').textContent = remainingCells;
            document.getElementById('hints-used').textContent = hintsUsed;
        }
        
        // Appliquer un thème
        function applyTheme(theme) {
            const root = document.documentElement;
            
            switch (theme) {
                case 'classic':
                    root.style.setProperty('--primary-color', '#6a5acd');
                    root.style.setProperty('--secondary-color', '#9370db');
                    root.style.setProperty('--accent-color', '#483d8b');
                    root.style.setProperty('--light-color', '#f8f8ff');
                    root.style.setProperty('--dark-color', '#2f2f4f');
                    root.style.setProperty('--correct-color', '#7fffd4');
                    root.style.setProperty('--error-color', '#ff7f7f');
                    document.body.style.backgroundColor = '#f8f8ff';
                    break;
                    
                case 'dark':
                    root.style.setProperty('--primary-color', '#bb86fc');
                    root.style.setProperty('--secondary-color', '#9e7fd9');
                    root.style.setProperty('--accent-color', '#7f55d2');
                    root.style.setProperty('--light-color', '#121212');
                    root.style.setProperty('--dark-color', '#e0e0e0');
                    root.style.setProperty('--correct-color', '#03dac6');
                    root.style.setProperty('--error-color', '#cf6679');
                    document.body.style.backgroundColor = '#121212';
                    break;
                    
                case 'ocean':
                    root.style.setProperty('--primary-color', '#0077b6');
                    root.style.setProperty('--secondary-color', '#00b4d8');
                    root.style.setProperty('--accent-color', '#0096c7');
                    root.style.setProperty('--light-color', '#e0f7fa');
                    root.style.setProperty('--dark-color', '#023e8a');
                    root.style.setProperty('--correct-color', '#4cc9f0');
                    root.style.setProperty('--error-color', '#f07167');
                    document.body.style.backgroundColor = '#e0f7fa';
                    break;
                    
                case 'forest':
                    root.style.setProperty('--primary-color', '#2e7d32');
                    root.style.setProperty('--secondary-color', '#4caf50');
                    root.style.setProperty('--accent-color', '#1b5e20');
                    root.style.setProperty('--light-color', '#e8f5e9');
                    root.style.setProperty('--dark-color', '#1b5e20');
                    root.style.setProperty('--correct-color', '#81c784');
                    root.style.setProperty('--error-color', '#e57373');
                    document.body.style.backgroundColor = '#e8f5e9';
                    break;
            }
        }
        
        // Obtenir la couleur de la palette
        function getColorFromPalette(colorCode) {
            const colors = {
                '0': '#000000', // Noir
                '1': '#ff0000', // Rouge
                '2': '#00ff00', // Vert
                '3': '#0000ff', // Bleu
                '4': '#ffff00'  // Jaune
            };
            
            return colors[colorCode] || '#000000';
        }
    </script>
</body>
</html>